#### （哪些注解可以应用于SpringMVC的controller层方法参数上）Which of these are annotations can be applied on Spring MVC controller method parameters? Select all that apply.
1. @ModelAttribute
2. @RequestHeader
3. @RequestBody
4. @RequestParam

##### 答案：1、2、3、4
###### 原因：
1. `@ModelAttribute`是一个SpringMVC注解，它主要用于==绑定请求参数到命令对象==（如表单提交），或者==将方法返回值添加到模型（Model）中==，以供视图使用。它可以==应用于方法参数或方法==上。
2. `@RequestHeader`是一个SpringWebFlux注解，用于将HTTP请求头绑定到控制器方法的参数上。==通过在控制器方法的参数上使用此注解并指定请求头的名称，可以轻松地访问该请求头的值==。
3. `@RequestBody`是一个SpringWebMVC注解，用于==将HTTP请求体绑定到控制器方法的参数上==。请求体通过一个适当的`HttpMessageConverter`进行解析，以根据请求的内容类型将其转换为方法参数所需的类型。主要用途是在处理JSON、XML等请求体格式的RESTful Web服务时使用。
4. `@RequestParam`是一个SpringWeb注解，用于将==HTTP请求参数绑定到控制器方法的参数上==。主要用于处理来自请求的查询参数、表单数据以及多部分请求的部分数据。

#### （正确的SpringSecurity过滤器顺序）Which of these show a proper ordering of Spring Security filters?
1. RememberMeAuthenticationFilter, UsernamePasswordAuthenticationFilter,ChannelProcessingFilter
2. ChannelProcessingFilter,FilterSecurityInterceptor,SecurityContextPersistenceFilter
3. ExceptionTranslationFilter,RememberMeAuthenticationFilter,ChannelProcessingFilter
4. BasicAuthenticationFilter,AnonymousAuthenticationFilter,FilterSecurityInterceptor

##### 答案：4
###### 原因：
SpringSecurity过滤器顺序为：
1. ChannelProcessingFilter - 与通道安全相关的过滤器,检测请求是否来自安全通道。
2. WebAsyncManagerIntegrationFilter - 与异步请求相关,在异步请求上下文中正确传播安全上下文。
3. SecurityContextPersistenceFilter - 在请求之间保存安全上下文以用于异步请求。
4. HeaderWriterFilter - 添加X-Content-Security-Policy、X-XSS-Protection等安全相关响应头。
5. CsrfFilter - 跨站点请求伪造防护过滤器,validate请求中的CSRF token。
6. LogoutFilter - 处理登出请求,清除安全上下文。 
7. UsernamePasswordAuthenticationFilter - 处理基于表单的登录请求。
8. DefaultLoginPageGeneratingFilter - 生成Spring Security默认登录页面。
9. BasicAuthenticationFilter - 用于HTTP Basic认证。
10. RequestCacheAwareFilter - 用于缓存请求以用于异步请求。
11. SecurityContextHolderAwareRequestFilter - 设置Spring Security上下文来代理HttpRequest。
12. AnonymousAuthenticationFilter - 检查当前请求是否已经过身份验证,如果没有则创建一个匿名Authentication对象。
13. SessionManagementFilter - 处理session相关的请求比如登录后的重定向,url权限校验等。
14. ExceptionTranslationFilter - 将Spring Security相关的异常翻译成HTTP响应。
15. FilterSecurityInterceptor - 确保URL访问权限校验。这个过滤器包含大部分Spring Security的核心功能。

#### （关于填空，为什么mvcMatchers比antMatchers更好）For the blank below, why would putting 'mvcMatchers' be better than putting 'antMatchers'? Select all that apply.
A method as blow exists
	@RequestMapping("/customer")
	public String customer(){

A security setting as below exists
	protected configure(HttpSecurity http) throws Exception {
		http.authorizeRequests().XXXXX.("/customer").hasRole("CUSTOMER");
	}

1. if 'antMatchers' is used, depending on the Spring MVC configuration, '/customer/' may not be protected.
2. if 'antMatchers' is used, depending on the Spring MVC configuration, '/customer.html' may not be protected.
3. if 'mvcMatchers' is used, the same URLs that Spring MVC matches on the URL, will be protected.
4. if 'antMatchers' is used, only '/customer' is protected.

##### 答案：1、2、3、4
###### 原因：
`mvcMatchers`是用于在SpringSecurity中==配置URL访问授权规则==时，根据SpringMVC请求匹配模式对HTTP请求进行匹配。它的作用是==根据指定的模式来判断当前的HTTP请求是否应该被允许或拒绝访问==。使用`mvcMatchers`可以==根据SpringMVC的匹配规则来配置访问授权==，如路径模式("/path")匹配"/path"、"/path/"、"/path.html"等URL。

`antMatchers`用于在SpringSecurity中==配置URL访问授权规则==时，根据==Ant风格==的路径模式对HTTP请求进行匹配。它的作用是==根据指定的模式来判断当前的HTTP请求是否应该被允许或拒绝访问==。使用`antMatchers`可以根据Ant风格的路径模式（例如：`/**/*.html`）来配置访问授权，这种路径模式比较简单且易于理解，可以很方便地匹配URL。

根据两种匹配模式的规则，根据题目配置，`antMatchers`只会匹配到'/customer'，而`mvcMatchers`则会匹配到"/path"、"/path/"、"path.html"等URL。

#### （使用多个实体管理器工厂时，将使用哪个）Which of these TransactionManager is used while using JPA with multiple entity manager factories in Spring Applications?
1. PlatFormTransactionManager
2. JpaTransactionManager
3. JtaTransactionManager

##### 答案：3
###### 原因：
1. `PlatFormTransactionManager`是一个==接口==，用于在Spring框架中==抽象事物管理==。它提供了一组方法，用于==处理事务的创建、提交、回滚以及获取事务状态==。在不同的事务管理器实现中，例如`DataSourceTransactionManager`和`JtaTransactionManager`，这些方法会有特定的实现以支持各种事务管理策略。`PlatformTransactionManager`==使得Spring框架能够以统一的方式处理事务==，而无需关心底层的事务管理技术。
2. `JpaTransactionManager`是一个实现了`PlatformTransactionManager`接口的类，用于在Spring框架中管理JPA事务。它处理JPA实体管理器（`EntityManager`）的==创建、事务的开始、提交、回滚等操作==，同时与底层的数据元（如果有的话）进行协调。
3. `JtaTransactionManager`是一个实现了`PlatformTransactionManager`接口的类，用于在Spring框架中管理JTA（Java Transaction API）事务。==它负责处理分布式事务==，即跨多个资源的事务（例如多个数据库或消息队列），也可以用来控制应用服务器资源（如通过JNDI获取的JDBC DataSource）上的事务。

#### （关于SpringWeb哪些说法是对的）Which of these is true in Spring web? Select all that apply.
1. AnnotationConfigWebApplicationContext can be used inside the web.xml when configuring a web application context.
2. The 'web' and 'request' bean scopes are only valid in the context of a web-aware Spring ApplicationContext
3. The 'session' and 'websocket' bean scopes are only valid in the context of a web-aware Spring ApplicationContext
4. Below can be used in specifying the @Configuration classes to be considered for a web application context, in web.xml.
```
<init-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>com.myPackage.MvcConfig</param-value>
</init-param>
```
##### 答案：1、3、4
###### 原因：
1. `AnnotationConfigWebApplicationContext`是一个基于注解的`WebApplicationContext`实现，用于在基于Servlet的Web应用中==引导注解类==（如`@Configuration`类）。==它允许使用注解配置来代替传统的XML配置==，在Web应用程序中定义并管理Spring bean。`AnnotationConfigWebApplicationContext`支持直接注册`@Configuration`类、使用组件扫描查找配置类以及使用基于注解的依赖注入。此类可与Spring的`ContextLoaderListener`或`DispatcherServlet`一起使用，使得在Web应用程序中使用Spring更加方便、简洁。默认情况下，==SpringBoot已配置该类==，可直接使用注解配置代替XML配置。在Spring中想使用该类，需要在web.xml中按如下配置（默认为`XmlWebApplicationContext`）
```
<context-param>
        <param-name>contextClass</param-name>
        <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
</context-param>
```
2. 没有web这个作用域，换成application就对了
3. 针对web应用，Spring提供了4个作用域：`request`、`Application`、`session`、`websocket`
4. 在web.xml中，配置@Configuration类需指定`<param-name>`为`contextConfiglocation`，其值则是配置类的全限定名。

#### （谁是Spring中的核心接口，用于向应用程序提供配置信息，并且有许多类实现了该接口，允许各种配置选项和应用程序类型）The XXX is the central interface within a Spring application for providing configuration information to the application. It is read-only at run time, but can be reloaded if necessary and supported by the application. A number of classes implement the XXX interface, allowing for a variety of configuration options and types of applications.
1. Bean,Bean
2. @Configuration,@Configuration
3. ConnectionFactory,ConnectionFactory
4. ApplicationContext,ApplicationContext

##### 答案：4
###### 原因：
1. `Bean`是用于在应用程序中管理对象实例的==核心概念==。Bean的主要作用（用途）有：
- `实例化和管理对象`：Spring容器负责创建对象实例（bean）并管理它们的生命周期。这使得开发者可以专注于业务逻辑，而==将对象创建、依赖管理等交给Spring容器处理==。
- `依赖注入`：Spring容器会自动将已注册的bean与其他需要依赖的bean关联起来。==依赖注入简化了对象之间的协作，并提高了代码的可测试性和可维护性==。
- `配置管理`：Spring容器可以用于管理bean的配置信息。通过将配置信息与实际的代码逻辑分离，==可以实现配置的集中管理和更容易的修改==。
- `生命周期管理`：Spring容器负责Bean的整个生命周期，从创建、初始化、使用到销毁。
2. `@Configuration`是一个==类级别的注解==，==用于指示带有该注解的类是一个Spring配置类==。在Spring框架中，配置类提供了一种通过Java代码（而非传统的XML文件）来配置Spring容器和应用程序的方法。使用`@Configuration`注解的类通常包含带有`@Bean`注解的方法。==这些方法用于初始化和配置应用程序的各个组件（即SpringBean）==。通过组合使用`@Configuration`和`@Bean`注解，开发者可以方便地创建和管理应用程序的组件，并可以在不同环境中灵活地进行配置。
3. `ConnectionFactory`是一种==设计模式==，在Java应用程序和服务（如数据库、消息队列等）之间建立连接时常被用到。它==主要用于管理和优化资源（如网络连接、数据库连接）的创建、使用和释放过程==。
4. `ApplicationContext`是Spring框架的==核心接口==，代表Spring应用程序上下文。它负责管理应用程序中的Bean，==它充当了应用程序各个组件之间的集线器，使得开发者可以更方便地组织、配置和管理整个应用程序==。并提供以下功能：
 - **Bean的创建、配置和管理**：`ApplicationContext`负责实例化、配置和组装应用程序中的Bean，以及在整个应用程序的生命周期内管理它们。
 - **事件发布和订阅**：`ApplicationContext`支持事件发布和订阅机制，允许Bean之间进行松耦合的通信。
 - **资源访问和国际化**：`ApplicationContext`提供了统一的接口，用于访问应用程序内的各种资源（文件、图像等），并支持国际化（本地化）处理。
 - **其他功能**：`Application`还提供了其他高级功能，如AOP（面向切面编程）集成、消息处理等。

#### （关于StringAop代理描述正确的是哪些）Which of these are true about Spring AOP proxies? Select all that apply
1. （如果代理对象没有实现任何接口，会使用CGLIB）CGLIB is necessary when proxying objects that does not implement any interface
2. （使用标准Jdk动态代理无法作用于没有通过接口暴露目标方法的目标对象）Spring AOP proxies that uses the standard JDK dynamic proxies cannot work with target objects that does not expose the target methods through interfaces.
3. （SpringAOP默认情况使用JDK动态代理模式）Spring AOP uses JDK dynamic proxies for AOP proxies by default.
4. （spring-core.jar包中包含了拥有CGLIB类的org.springframework.cglib包）CGLIB classes are under the org.springframework.cglib package and included in the spring-core jar.

##### 答案：1、2、3、4
###### 原因：
1. ==CGLIB通过继承目标对象==来生成代理，==JDK基于接口==进行代理，而Spring选择动态代理的判断规则是：
- 如果目标对象至少实现一个接口，则会选择JDK动态代理
- ==如果目标对象没有实现任何接口，则会选择CGLIB代理==。
- 可以通过`proxy-target-class=true`显式指定使用CGLIB代理。
2. JDK动态代理需要基于接口创建代理对象。它会生成接口的代理对象，并实现接口中的方法。所以如果目标对象没有实现任何接口，JDK动态代理无法为其生成代理对象。
3. ==默认情况下Spring会使用JDK动态代理方式==，在目标类没有实现任何接口的情况下才会使用CGLIB。
4. CGLIB是Spring框架中用来代理不能被JDK代理的类的工具，它使用字节码技术来生成指定类的子类。CGLIB相关类有：
- **CglibProxyFactoryBean**：用于创建CGLIB代理
- **Enhancer**：用来动态生成代理类
- **Callback**：代理类调用目标类方法时会调用回调对象中的对应方法
- **MethodInterceptor**：方法拦截器，实现此接口可以拦截代理类方法调用
==这些关键类均位于== `org.springframework.cglib`==包下==，是CGLIB代理的基石。其次，==CGLIB的依赖已包含在Spring Framework的spring-core模块中==，我们无需显式引入CGLIB相关依赖，只需要引入spring-core即可使用CGLIB代理。

#### （关于安全和Spring安全的正确描述）Which of these are true regarding security and Spring Security?Select all that apply
1. （SpringSecurity的PasswordEncoder用于密码加密）Spring Security's PasswordEncoder helps in working with encoded passwords
2. （如果用于创建哈希的算法已知，则从哈希中获取原始值会相对容易）if the algorithm used to create the hash is known, it is relatively simple to obtain the orginal value from the hash.
3. （盐是每个用户的附加已知字符串，在计算哈希之前与密码组合使用）A salt is an additional string of known data for each user which is combined with the password before calculating the hash.
4. （哈希是一个使用选定算法，从某些输入数据生成的固定长度输出数据）A hash is a piece of fixed-length output data from some input data, using a chosen algorithm.

##### 答案：1、3、4
###### 原因：
