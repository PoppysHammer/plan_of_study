#### （哪些注解可以应用于SpringMVC的controller层方法参数上）Which of these are annotations can be applied on Spring MVC controller method parameters? Select all that apply.
1. @ModelAttribute
2. @RequestHeader
3. @RequestBody
4. @RequestParam

##### 答案：1、2、3、4
###### 原因：
1. `@ModelAttribute`是一个SpringMVC注解，它主要用于==绑定请求参数到命令对象==（如表单提交），或者==将方法返回值添加到模型（Model）中==，以供视图使用。它可以==应用于方法参数或方法==上。
2. `@RequestHeader`是一个SpringWebFlux注解，用于将HTTP请求头绑定到控制器方法的参数上。==通过在控制器方法的参数上使用此注解并指定请求头的名称，可以轻松地访问该请求头的值==。
3. `@RequestBody`是一个SpringWebMVC注解，用于==将HTTP请求体绑定到控制器方法的参数上==。请求体通过一个适当的`HttpMessageConverter`进行解析，以根据请求的内容类型将其转换为方法参数所需的类型。主要用途是在处理JSON、XML等请求体格式的RESTful Web服务时使用。
4. `@RequestParam`是一个SpringWeb注解，用于将==HTTP请求参数绑定到控制器方法的参数上==。主要用于处理来自请求的查询参数、表单数据以及多部分请求的部分数据。

#### （正确的SpringSecurity过滤器顺序）Which of these show a proper ordering of Spring Security filters?
1. RememberMeAuthenticationFilter, UsernamePasswordAuthenticationFilter,ChannelProcessingFilter
2. ChannelProcessingFilter,FilterSecurityInterceptor,SecurityContextPersistenceFilter
3. ExceptionTranslationFilter,RememberMeAuthenticationFilter,ChannelProcessingFilter
4. BasicAuthenticationFilter,AnonymousAuthenticationFilter,FilterSecurityInterceptor

##### 答案：4
###### 原因：
SpringSecurity过滤器顺序为：
1. ChannelProcessingFilter - 与通道安全相关的过滤器,检测请求是否来自安全通道。
2. WebAsyncManagerIntegrationFilter - 与异步请求相关,在异步请求上下文中正确传播安全上下文。
3. SecurityContextPersistenceFilter - 在请求之间保存安全上下文以用于异步请求。
4. HeaderWriterFilter - 添加X-Content-Security-Policy、X-XSS-Protection等安全相关响应头。
5. CsrfFilter - 跨站点请求伪造防护过滤器,validate请求中的CSRF token。
6. LogoutFilter - 处理登出请求,清除安全上下文。 
7. UsernamePasswordAuthenticationFilter - 处理基于表单的登录请求。
8. DefaultLoginPageGeneratingFilter - 生成Spring Security默认登录页面。
9. BasicAuthenticationFilter - 用于HTTP Basic认证。
10. RequestCacheAwareFilter - 用于缓存请求以用于异步请求。
11. SecurityContextHolderAwareRequestFilter - 设置Spring Security上下文来代理HttpRequest。
12. AnonymousAuthenticationFilter - 检查当前请求是否已经过身份验证,如果没有则创建一个匿名Authentication对象。
13. SessionManagementFilter - 处理session相关的请求比如登录后的重定向,url权限校验等。
14. ExceptionTranslationFilter - 将Spring Security相关的异常翻译成HTTP响应。
15. FilterSecurityInterceptor - 确保URL访问权限校验。这个过滤器包含大部分Spring Security的核心功能。

#### （关于填空，为什么mvcMatchers比antMatchers更好）For the blank below, why would putting 'mvcMatchers' be better than putting 'antMatchers'? Select all that apply.
A method as blow exists
	@RequestMapping("/customer")
	public String customer(){

A security setting as below exists
	protected configure(HttpSecurity http) throws Exception {
		http.authorizeRequests().XXXXX.("/customer").hasRole("CUSTOMER");
	}

1. if 'antMatchers' is used, depending on the Spring MVC configuration, '/customer/' may not be protected.
2. if 'antMatchers' is used, depending on the Spring MVC configuration, '/customer.html' may not be protected.
3. if 'mvcMatchers' is used, the same URLs that Spring MVC matches on the URL, will be protected.
4. if 'antMatchers' is used, only '/customer' is protected.

##### 答案：1、2、3、4
###### 原因：
`mvcMatchers`是用于在SpringSecurity中==配置URL访问授权规则==时，根据SpringMVC请求匹配模式对HTTP请求进行匹配。它的作用是==根据指定的模式来判断当前的HTTP请求是否应该被允许或拒绝访问==。使用`mvcMatchers`可以==根据SpringMVC的匹配规则来配置访问授权==，如路径模式("/path")匹配"/path"、"/path/"、"/path.html"等URL。

`antMatchers`用于在SpringSecurity中==配置URL访问授权规则==时，根据==Ant风格==的路径模式对HTTP请求进行匹配。它的作用是==根据指定的模式来判断当前的HTTP请求是否应该被允许或拒绝访问==。使用`antMatchers`可以根据Ant风格的路径模式（例如：`/**/*.html`）来配置访问授权，这种路径模式比较简单且易于理解，可以很方便地匹配URL。

根据两种匹配模式的规则，根据题目配置，`antMatchers`只会匹配到'/customer'，而`mvcMatchers`则会匹配到"/path"、"/path/"、"path.html"等URL。

#### （使用多个实体管理器工厂时，将使用哪个）Which of these TransactionManager is used while using JPA with multiple entity manager factories in Spring Applications?
1. PlatFormTransactionManager
2. JpaTransactionManager
3. JtaTransactionManager

##### 答案：3
###### 原因：
1. `PlatFormTransactionManager`是一个==接口==，用于在Spring框架中==抽象事物管理==。它提供了一组方法，用于==处理事务的创建、提交、回滚以及获取事务状态==。在不同的事务管理器实现中，例如`DataSourceTransactionManager`和`JtaTransactionManager`，这些方法会有特定的实现以支持各种事务管理策略。`PlatformTransactionManager`==使得Spring框架能够以统一的方式处理事务==，而无需关心底层的事务管理技术。
2. `JpaTransactionManager`是一个实现了`PlatformTransactionManager`接口的类，用于在Spring框架中管理JPA事务。它处理JPA实体管理器（`EntityManager`）的==创建、事务的开始、提交、回滚等操作==，同时与底层的数据元（如果有的话）进行协调。
3. `JtaTransactionManager`是一个实现了`PlatformTransactionManager`接口的类，用于在Spring框架中管理JTA（Java Transaction API）事务。==它负责处理分布式事务==，即跨多个资源的事务（例如多个数据库或消息队列），也可以用来控制应用服务器资源（如通过JNDI获取的JDBC DataSource）上的事务。

#### （关于SpringWeb哪些说法是对的）Which of these is true in Spring web? Select all that apply.
1. AnnotationConfigWebApplicationContext can be used inside the web.xml when configuring a web application context.
2. The 'web' and 'request' bean scopes are only valid in the context of a web-aware Spring ApplicationContext
3. The 'session' and 'websocket' bean scopes are only valid in the context of a web-aware Spring ApplicationContext
4. Below can be used in specifying the @Configuration classes to be considered for a web application context, in web.xml.
```
<init-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>com.myPackage.MvcConfig</param-value>
</init-param>
```
##### 答案：1、3、4
###### 原因：
1. `AnnotationConfigWebApplicationContext`是一个基于注解的`WebApplicationContext`实现，用于在基于Servlet的Web应用中==引导注解类==（如`@Configuration`类）。==它允许使用注解配置来代替传统的XML配置==，在Web应用程序中定义并管理Spring bean。`AnnotationConfigWebApplicationContext`支持直接注册`@Configuration`类、使用组件扫描查找配置类以及使用基于注解的依赖注入。此类可与Spring的`ContextLoaderListener`或`DispatcherServlet`一起使用，使得在Web应用程序中使用Spring更加方便、简洁。默认情况下，==SpringBoot已配置该类==，可直接使用注解配置代替XML配置。在Spring中想使用该类，需要在web.xml中按如下配置（默认为`XmlWebApplicationContext`）
```
<context-param>
        <param-name>contextClass</param-name>
        <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
</context-param>
```
2. 没有web这个作用域，换成application就对了
3. 针对web应用，Spring提供了4个作用域：`request`、`Application`、`session`、`websocket`
4. 在web.xml中，配置@Configuration类需指定`<param-name>`为`contextConfiglocation`，其值则是配置类的全限定名。

#### （谁是Spring中的核心接口，用于向应用程序提供配置信息，并且有许多类实现了该接口，允许各种配置选项和应用程序类型）The XXX is the central interface within a Spring application for providing configuration information to the application. It is read-only at run time, but can be reloaded if necessary and supported by the application. A number of classes implement the XXX interface, allowing for a variety of configuration options and types of applications.
1. Bean,Bean
2. @Configuration,@Configuration
3. ConnectionFactory,ConnectionFactory
4. ApplicationContext,ApplicationContext

##### 答案：4
###### 原因：
1. `Bean`是用于在应用程序中管理对象实例的==核心概念==。Bean的主要作用（用途）有：
- `实例化和管理对象`：Spring容器负责创建对象实例（bean）并管理它们的生命周期。这使得开发者可以专注于业务逻辑，而==将对象创建、依赖管理等交给Spring容器处理==。
- `依赖注入`：Spring容器会自动将已注册的bean与其他需要依赖的bean关联起来。==依赖注入简化了对象之间的协作，并提高了代码的可测试性和可维护性==。
- `配置管理`：Spring容器可以用于管理bean的配置信息。通过将配置信息与实际的代码逻辑分离，==可以实现配置的集中管理和更容易的修改==。
- `生命周期管理`：Spring容器负责Bean的整个生命周期，从创建、初始化、使用到销毁。
2. `@Configuration`是一个==类级别的注解==，==用于指示带有该注解的类是一个Spring配置类==。在Spring框架中，配置类提供了一种通过Java代码（而非传统的XML文件）来配置Spring容器和应用程序的方法。使用`@Configuration`注解的类通常包含带有`@Bean`注解的方法。==这些方法用于初始化和配置应用程序的各个组件（即SpringBean）==。通过组合使用`@Configuration`和`@Bean`注解，开发者可以方便地创建和管理应用程序的组件，并可以在不同环境中灵活地进行配置。
3. `ConnectionFactory`是一种==设计模式==，在Java应用程序和服务（如数据库、消息队列等）之间建立连接时常被用到。它==主要用于管理和优化资源（如网络连接、数据库连接）的创建、使用和释放过程==。
4. `ApplicationContext`是Spring框架的==核心接口==，代表Spring应用程序上下文。它负责管理应用程序中的Bean，==它充当了应用程序各个组件之间的集线器，使得开发者可以更方便地组织、配置和管理整个应用程序==。并提供以下功能：
 - **Bean的创建、配置和管理**：`ApplicationContext`负责实例化、配置和组装应用程序中的Bean，以及在整个应用程序的生命周期内管理它们。
 - **事件发布和订阅**：`ApplicationContext`支持事件发布和订阅机制，允许Bean之间进行松耦合的通信。
 - **资源访问和国际化**：`ApplicationContext`提供了统一的接口，用于访问应用程序内的各种资源（文件、图像等），并支持国际化（本地化）处理。
 - **其他功能**：`Application`还提供了其他高级功能，如AOP（面向切面编程）集成、消息处理等。

#### （关于StringAop代理描述正确的是哪些）Which of these are true about Spring AOP proxies? Select all that apply
1. （如果代理对象没有实现任何接口，会使用CGLIB）CGLIB is necessary when proxying objects that does not implement any interface
2. （使用标准Jdk动态代理无法作用于没有通过接口暴露目标方法的目标对象）Spring AOP proxies that uses the standard JDK dynamic proxies cannot work with target objects that does not expose the target methods through interfaces.
3. （SpringAOP默认情况使用JDK动态代理模式）Spring AOP uses JDK dynamic proxies for AOP proxies by default.
4. （spring-core.jar包中包含了拥有CGLIB类的org.springframework.cglib包）CGLIB classes are under the org.springframework.cglib package and included in the spring-core jar.

##### 答案：1、2、3、4
###### 原因：
1. ==CGLIB通过继承目标对象==来生成代理，==JDK基于接口==进行代理，而Spring选择动态代理的判断规则是：
- 如果目标对象至少实现一个接口，则会选择JDK动态代理
- ==如果目标对象没有实现任何接口，则会选择CGLIB代理==。
- 可以通过`proxy-target-class=true`显式指定使用CGLIB代理。
2. JDK动态代理需要基于接口创建代理对象。它会生成接口的代理对象，并实现接口中的方法。所以如果目标对象没有实现任何接口，JDK动态代理无法为其生成代理对象。
3. ==默认情况下Spring会使用JDK动态代理方式==，在目标类没有实现任何接口的情况下才会使用CGLIB。
4. CGLIB是Spring框架中用来代理不能被JDK代理的类的工具，它使用字节码技术来生成指定类的子类。CGLIB相关类有：
- **CglibProxyFactoryBean**：用于创建CGLIB代理
- **Enhancer**：用来动态生成代理类
- **Callback**：代理类调用目标类方法时会调用回调对象中的对应方法
- **MethodInterceptor**：方法拦截器，实现此接口可以拦截代理类方法调用
==这些关键类均位于== `org.springframework.cglib`==包下==，是CGLIB代理的基石。其次，==CGLIB的依赖已包含在Spring Framework的spring-core模块中==，我们无需显式引入CGLIB相关依赖，只需要引入spring-core即可使用CGLIB代理。

#### （关于安全和Spring安全的正确描述）Which of these are true regarding security and Spring Security?Select all that apply
1. （SpringSecurity的PasswordEncoder用于密码加密）Spring Security's PasswordEncoder helps in working with encoded passwords
2. （如果用于创建哈希的算法已知，则从哈希中获取原始值会相对容易）if the algorithm used to create the hash is known, it is relatively simple to obtain the orginal value from the hash.
3. （盐是每个用户的附加已知字符串，在计算哈希之前与密码组合使用）A salt is an additional string of known data for each user which is combined with the password before calculating the hash.
4. （哈希是一个使用选定算法，从某些输入数据生成的固定长度输出数据）A hash is a piece of fixed-length output data from some input data, using a chosen algorithm.

##### 答案：1、3、4
###### 原因：
1. SpringSecurity提供了`PasswordEncoder`接口来==定义密码的加密与匹配规则==，用于对密码进行==单向转换（不可逆）==，使密码能够安全地存储。它通常用于在认证过程中，将用户提供的密码与存储的加密密码进行比较。这种单向转换不适用于需要双向转换的密码存储场景，例如存储用于验证数据库连接的凭证。
2. 如果使用了安全的哈希算法，即使知道算法，==从哈希值反推出原始值仍然是非常困难的==。好的哈希函数具有==抗碰撞性==，这意味着即使是微小的输入变化也会导致完全不同的输出哈希值。此外，安全的哈希函数也具有==抗预测性==，即无法通过哈希值推断出原始输入。因此，知道算法并不能轻易地从哈希值中获取原始值。
3. 盐（salt）在密码哈希中的==作用是增加破解密码的难度==。盐是一个随机生成的值，==与用户密码一起使用==，通过哈希函数生成加密后的密码哈希值。添加盐的目的有以下几点：
- **增加破解难度**：由于盐是随机生成的，每个生成用户的盐值都不同，这使得攻击者在破解密码时无法预先计算哈希表（例如：彩虹表）。
- **防止相同明文密码哈希值相同**：即使两个用户使用相同的明文密码，由于盐值的随机性，加密后的哈希值也会不同。
- **抵抗字典攻击**：由于盐的存在，攻击者需要针对每个用户单独进行破解尝试，无法对比字典表直接确定原始密码。
4. 哈希（hash）是一种算法，==用于将任意长度的数据输入（通常为字符串）转换为固定长度的输出值==。输出值通常称为哈希值。哈希函数具有以下特性：
- 相同的输入总是产生相同的输出
- 不同的输入产生不同的输出，即使输入数据之间的差别很小
- 由输出值返回原始输入是非常困难的
- 输出空间足够大，以减少哈希值碰撞的可能性

#### （其中哪些是HTTP中的谓词，用于执行对资源的操作）Which of these are HTTP verbs which are used as actions to execute on the resources? Select all that apply.
1. PUT
2. HEAD
3. POST
4. DELETE
5. GET

##### 答案：1、2、3、4、5
###### 原因：
HTTP谓词用于定义对资源执行的操作，主要的HTTP谓词有：
- **GET**：获取资源，==安全且幂等的==。
- **POST**：创建资源，==非幂等的==。
- **PUT**：替换资源，==幂等的==。
- **PATCH**：更新资源，==非幂等的==。
- **DELETE**：删除资源，==幂等的==。
- **HEAD**：获取资源头信息，==安全且幂等的==。
- **OPTIONS**：获取资源支持的操作，==安全且幂等的==。

#### （下列哪个是@Lazy最常用的方式）In which of these, the @Lazy annotation is correctly used?
1. @Lazy(false)
2. @Lazy
3. @Scope("Lazy")
4. @Lazy("true")

##### 答案：2
###### 原因：
`@Lazy`是用来标注某个方法或属性是延迟初始化的（Lazy Initialization）所谓延迟初始化，就是在第一次使用时才初始化，而不是在定义时直接初始化。==该注解只包含一个boolean类型的value属性，默认为true。==

#### （当bean未使用@profile与配置文件关联时：）When the bean is not associated to the profile using @profile():
1. A & C
2. （bean必须隐式关联到配置文件）The bean must be implicitly associated to the profile using
3. （bean在所有配置环境下可用）The bean is availble on each profile
4. （bean只在默认配置环境下可用）The bean is only available on default profile

##### 答案：3
###### 原因：
`@Profile`的作用是根据运行环境的profile有条件地使bean生效或不生效。在Spring应用中，profile代表不同的运行环境，如：
- prod：生产环境
- dev：开发环境
- test：测试环境
使用`@Profile`的主要好处是：
- 使Spring上下文（context）变得更加轻量级。因为只会实例化当前profile下的bean，其他profile的bean会被忽略。
- 避免bean定义之间的冲突。可以为每个环境定义不同的bean，防止不同环境下的bean冲突。
- 更清晰的区分不同环境下的配置。prod环境和dev环境的配置可以清晰分离。
不加`@Profile`的bean会在所有环境下实例化，不区分环境配置。

#### （下列哪个http操作被认为是幂等的）Which of these HTTP actions are considered to be idempotent?
1. POST
2. GET
3. PUT
4. DELETE

##### 答案：2、3、4
###### 原因：
幂等（idempotent）的HTTP操作意味着==多次执行该操作的结果与一次执行的结果相同==。
常见的==幂等HTTP操作==有：
- **GET**：获取资源。多次获取同一个资源，结果相同。
- **HEAD**：获取资源头部信息。多次请求同一个资源，结果相同。
- **OPTIONS**：获取资源支持的HTTP方法。多次请求同一个资源，结果相同。
- **PUT**：更新资源。多次更新同一个资源，结果相同。
- **DELETE**：删除资源。多次删除同一个资源，结果相同。
==非幂等的HTTP操作==有：
- **POST**：创建新资源。多次执行会创建多个资源，结果不同。
严格来说，HTTP协议层面定义的幂等操作在网络环境的执行并不一定是真正幂等的，还需要应用维持资源状态和重试机制等手段来确保操作的幂等性。幂等性是构建RESTAPI的重要原则之一。了解HTTP中哪些操作是幂等的，有助于设计出合理的API接口。

#### （intercept-url标签中哪个属性会导致任何匹配的请求完全绕过过滤器？）In Spring Security, which of these is the attribute of the 'intercept-url' element which can cause any matching request to bypass the filter chain entirely?
1. access
2. filters
3. pattern
4. requires-channel

##### 答案：B
###### 原因：
`intercept-url`标签具有以下属性：
`pattern`或`request-matcher-ref`：**用于定义要拦截的请求路径模式**
`access`：**为指定路径设置访问权限配置属性**
`method`：**适用于访问配置属性的HTTP方法**；如果未指定，则属性将适用于任何方法
`requires-channel`：**指定URL必须通过HTTP或HTTPS访问，或无要求**；值应为"http"，"https"或"any"
`filters`：**只能取值"none"，这将导致任何匹配的请求完全绕过Spring Security过滤器链**。\<http\>配置的其余部分都不会对请求产生任何影响，并且在其持续时间内没有可用的安全上下文。在请求期间访问安全方法将失败。

#### （关于安全性和SpringSecurity哪些描述是正确的）which of these are true about security and Spring Security? Select all that apply.  题目有误 实际题目为：关于安全性和SpringAOP哪些描述是正确的
1. （如果需要比方法调用更精细的安全保护，SpringAOP不是最优选，例如需要直接保护实体对象，AspectJ会是更好的选择）Spring AOP is not the best solution if you need to secure in finer detail than method invocations. For example, if you need to secure domain objects directly, AspectJ could be a better choice.
2. （Spring使用SpringAOP保护方法调用）Spring secures method invocations using Spring AOP.
3. （Security是横切面关注点）Security is a cross-cutting concern.
4. （Spring使用SpringAOP保护web请求）Spring secures web requests using Spring AOP.

##### 答案：1、2、3
###### 原因：
1. SpringAOP和AspectJ是两种主流的AOP框架，它们之间有以下主要区别：
**织入方式**
- SpringAOP通过==代理机制==实现织入，是==运行时==织入。它只能在==方法执行级别==上进行织入。
- AspectJ有==编译时==织入和==运行时==织入两种方式。编译时织入可以在==方法调用==、==属性赋值==等==更细粒度==的级别上进行织入。运行时织入的功能与SpringAOP类似。
**功能强大程度**
- SpringAOP功能相对简单，只支持==方法级别==调用的织入，适用于较为基本的AOP需求。
- AspectJ是一个成熟的AOP框架，功能更加强大，支持==方法调用==、==方法执行==、==构造器==、==属性赋值==、==异常处理==等各个级别的织入，可以实现更加==复杂==的AOP需求。
**语言支持**
- SpringAOP仅支持Java和.NET语言
- AspectJ支持Java、.NET、==Python等==更多语言。
**学习难度**
- SpringAOP相对简单，易于学习和使用。
- AspectJ==功能更强大==，语言本身的学习==难度也较大==，==门槛较高==。
**与Spring的整合**
- SpringAOP是Spring框架的一部分，与Spring自然整合。
- AspectJ需要使用==@AspectJ==注解与Spring进行整合，Spring也提供了对AspectJ的很好支持。
2. SpringAOP可以在==方法调用级别==织入各种切面逻辑。 SpringSecurity就是==利用SpringAOP==来实现==方法级别==的==安全控制==的。SpringSecurity的原理是：围绕需要==保护的方法调用织入校验权限==的切面逻辑。当有请求调用受保护的方法时，会先经过SpringSecurity的权限校验逻辑，判断请求是否有权限访问该方法，如果通过校验则放行，如果校验不通过则抛出异常阻止方法调用。
3. ==安全性==是一个典型的横切关注点，因为它涉及到应用的多个模块和层级。
4. 在Spring官方文档：**Security and AOP Advice**一节中表示，==web请求使用过滤器保护==![[Pasted image 20230524095059.png]]
#### （关于SpringSecurity，哪些描述是正确的）In Spring Security,which of these is true?
1. （filter-chain是用于配置过滤器链的，包含一个属性，可以指定自己想用的过滤器）\<filter-chain\> is used to set up security filter chains. It includes an attribute where you can specify the filters that you prefer to use.
2. （FilterChainProxy是一个实现了Filter接口的Filter）FilterChainProxy is a Filter (implements Java's Filter interface).
3. （intercept-url可以用于定义URL模式及其处理方式）\<intercept-url\> can be used to define URL patterns and how they should be handled.
4. All of the above.

##### 答案：4
###### 原因：
1. `<filter-chain>`是用于==配置SpringSecurity中的过滤器链==。在Servlet架构中，过滤器链的作用是确定哪些SpringSecurity`Filter`实例应用于当前请求。它包含一个`filters`属性，可以在其中指定希望使用的过滤器列表。
2. `FilterChainProxy`是一个实现了JavaServlet`Filter`接口的类，在SpringSecurity中，它负责==接收并处理HTTP请求==，将请求==传递==给一系列的安全过滤器进行处理（比如身份验证和授权），并将结果返回给客户端。通过将多个过滤器组合在一起，`FilterChainProxy`能够灵活地管理和配置应用程序的安全策略。
3. `<intercept-url>`元素用于==定义应用程序中特定URL路径的访问控制规则==。它通常与`<http>`元素一起使用，以配置SpringSecurity的安全策略。`<intercept-url>`元素可以指定URL模式（使用`pattern`属性)，并指定相应的访问权限（使用`access`属性）。通过将多个`<intercept-url>`元素组合在一起，您可以为不同的URL路径设置不同的安全策略。

#### （关于PropertySourcesPlaceSourcesPlaceholder类的描述哪些是正确的）Which of these is true about the PropertySourcesPlaceholderConfigurer class? Select all that apply.
1. （解析@Value注解）resolves @Value annotations
2. （解析@Autowired注解）resolves @Autowired annotations
3. （解析bean定义属性值中的${...}占位符）resolves ${...} placeholders within bean definition property values
4. （专业化的PlaceholderConfigurerSupport）specialization of PlaceholderConfigurerSupport

##### 答案：1、3、4
###### 原因：
`PropertySourcesPlaceholderConfigurer`是一个`BeanFactoryPostProcessor`，继承自`PlaceholderConfigurerSupport`，它的作用是将检查Spring配置文件中以`${...}`形式出现的变量替换为实际值。主要步骤是：
- 检查Spring配置文件，寻找以`${...}`形式出现的变量
- 对每个变量，从配置的`property sources`中查找名称匹配的属性值
- 如果找到，则将变量替换为属性值；如果没找到则忽略。
- 重复执行以上步骤，直到Spring配置文件中不再出现未替换的变量为止。
这个过程发生在==Spring应用刷新之前==，目的是让变量的值准备就绪，注入到Spring容器中。
`PropertySourcesPlaceholderConfigurer`支持解析的注解有：`@Value`、`@PropertySource`、`SpEL表达式`

#### （哪些是Spring配置文件的有效用法）Which of these are valid usages of Spring profiles? Select all that apply.
1. 
```
@Profile({exclude="production"})
@Configuration
public class MyConfig{
```
2. 
```
@Configuration
public class MyConfig{
	@Profile({"dev"})
	@Bean
	public MyService myService(){
```
3. 
```
@Configuration
public class MyConfig {
	@Profile({"dev","staging"})
	@Bean
	public MyService myService(){
```
4. 
```
@Profile({"!production"})
@Configuration
public class MyConfig {
```
##### 答案：2、3、4
###### 原因：
`@Profile`是用于根据环境标识启用或禁用Bean的注册，其包含的属性只有`String[] value`，该注解的作用域有`Type`、`Method`，支持==与或非==运算符。

