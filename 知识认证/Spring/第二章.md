#### （拦截请求的过滤器）In Spring Security, **XXX** is a filter which implements javax.servlet. filter interface and which intercepts all the requests sent to an application.
1. FilterChainProxy（过滤器链代理）
2. DelegatingFilterProxy（委派过滤器代理）
3. DelegatingProxy（委派代理）

##### 答案 ： 2
###### 原因： 
1. FilterChainProxy 是SpringSecurity框架中的一个核心组件，它负责==负责处理请求的过滤器链。==。它通常与应用程序的**web.xml**文件中配置的**DelegatingFilterProxy**一起使用。
2. DelegatingFilterProxy是SpringSecurity框架中的一个过滤器代理，主要作用==将Servlet容器的过滤请求委托给Spring容器管理的过滤器 bean==。它通常在应用程序的**web.xml**中配置，并与**FilterChainProxy**搭配使用，从而让Spring容器负责过滤器的生命周期管理。
3. DelegatingProxy不存在

#### （专用于JPA的测试注解）Which of these annotation is used to annotate test-classes that contain tests of only JPA components?
1. @DataJpaTest
2. @JpaTest
3. @DataTest
4. @JpaDataTest

##### 答案：1
###### 原因：
1. @DataJpaTest 注解用于SpringBoot项目中测试JPA存储库，可用于设置嵌入式数据库、配置SpringDataJpa并扫描实体类和存储库。此外，==它还可以帮助配置测试切片并禁用完整的自动配置，使测试运行速度更快，仅关注与JPA相关的组件。==
2. @JpaTest不存在
3. @DataTest不存在
4. @JpaDataTest不存在

#### （设置SpringBoot自动配置候选项-starter）Which of these file is used to locate candidates for autoconfiguration in a Spring Boot application
1. spring.factories
2. application.properties
3. POM.xml
4. A class annotated with @EnableAutoConfiguration

##### 答案：1
###### 原因：
1. spring.factories是用于Spring框架中的==服务加载机制==。它允许==多个Jar文件中的工厂实现自动加载==。`spring.factories`文件需使用`Properties`格式，其中键是接口或抽象类的完全限定名，值是逗号分隔的实现类名列表。例如：`example.MyService=example.MyServiceImpl1,example.MyServiceImpl2`其中 `example.MyService` 是接口名称，而 `MyServiceImpl1` 和 `MyServiceImpl2` 是两个实现类。当需要自动发现并实例化某接口或抽象类的实现时，可以使用`SpringFactoriesLoader`类来从`spring.factories`文件中加载这些实现。
2. application.properties文件用于==存储SpringBoot应用程序的配置信息==。通过这个文件，您可以自定义==应用程序的各种配置设置==，例如==数据源配置==、==服务器端口==、==日志级别==等。当SpringBoot应用程序启动时，它会自动加载并读取`application.properties`文件中的配置信息。这种集中式的配置管理方式使得在开发、测试和生产环境中切换不同的配置变得更加容易。
3. POM.xml文件是==Maven构建工具用于管理项目的配置文件==。POM（Project Object Model）表示项目对象模型，它包含了==项目的基本信息==（例如名称、版本和描述等）、==项目的依赖关系==、==构建设置==（如插件和目标）、以及==其他配置项==。Maven使用`pom.xml`文件中的信息来构建、测试和部署项目。这个文件让项目的==构建过程更加标准化和可重复==，同时可以帮助你管理项目的所有依赖关系，确保项目在不同环境中的一致性。
4. @EnableAutoConfiguration注解用于==启用SpringBoot的自动配置功能==。自动配置根据类路径上的类库和应用程序中定义的beans来为应用程序提供合适的默认配置。如果某个库存在于类路径中，但应用程序没有显式配置该库，SpringBoot将尝试提供一个合适的默认配置。例如，如果类路径中包含数据库连接驱动程序，SpringBoot会自动配置一个数据源和相关的连接属性。为了启用自动配置，你需要在你的配置类或主类上添加`@EnableAutoConfiguration`注解。通常，`@SpringBootApplication`注解==已经包含==了`@EnableAutoConfiguration`，所以在大多数情况下，不需要显示地添加此注解。

#### （配置类中注解式启用事务管理）Which of these annotation is used to annotate exactly one configuration class in an application for enabling annotation-driven transaction management?
1. @EnableTransactionManagement
2. @EnableTransaction
3. @Transactional
4. @TransactionManagement
##### 答案：1
###### 原因：
1. @EnableTransactionManagement注解用于==启用Spring的注解驱动的事务管理功能==。它允许您使用`@Transactional`注解来声明事务边界。在使用了`@EnableTransactionManagement`==的配置类中==，Spring框架会==自动==配置事务管理的基础设施以支持事务处理。
2. @EnableTransaction不存在
3. @Transactional注解用于==声明事务边界==。它可以应用于类或方法上。当在方法上使用`@Transactional`注解时，它标识该方法需要在一个事务上下文中运行。Spring将确保方法的执行在一个数据库事务中进行，如果在执行过程中发生任何异常，事务将回滚，否则事务将被提交。这样可以确保数据的一致性和完整性。可以通过提供不同的属性（如传播行为、隔离级别、超时、只读等）来定制事务的行为。
4. @TransactionManagement不存在

#### （SpringSecurity中负责管理用户信息的对象）In Spring Security **XXX** holds the information of user like username or password
1. UserDetailsService
2. UserServiceDetails
3. UserService（UserDetails）
##### 答案：C
###### 原因：
1. UserDetailsService是一个==接口==，用于==加载用户特定的数据==。在SpringSecurity框架中，它被用作用户DAO（Data Access Object），并作为`DaoAuthenticationProvider`的策略。这个接口==只需要一个只读方法==`loadUserByUsername`，这简化了对新数据访问策略的支持。该方法接受一个用户名作为参数，==通过这个用户名来查找用户==，并返回一个完全填充的用户记录（`UserDetails`类型）。如果找不到用户或者用户没有授权，会抛出`UsernameNotFoundException`异常。
2. UserServiceDetails不存在
3. UserService（题目出错，实际为UserDetails）UserDetails是一个==接口==，标识用户的核心信息，用于SpringSecurity框架的==认证和授权。==`UserDetails`==包含了一些重要属性==，如用户名、密码、角色、权限、账户是否可用等。这些信息用于不同的认证和授权策略。`UserDetailsService`接口的`loadUserByUsername(String username)`方法返回一个`UserDetails`对象，用于检索用户的详细信息。

#### （SpringSecurity哪个注解可以代替@Secured）In Spring Security，@Secured annotation is a legacy Annotation from Spring 2.x Version.In place of @Secured,which of these annotation can be used?
1. @PreFilter
2. @RolesAllowed
3. @PreAuthorize
4. @PostFilter
##### 答案：3
###### 原因：
@Secured
1. @PreFilter注解用于指定在==调用方法之前应执行==的一个过滤表达式。它主要用于对方法参数中的集合进行过滤。`@PreFilter`的作用==是移除那些在表达式中求值为`false`的集合元素==。`value()`属性用于==定义一个Spring-EL表达式==，该表达式将在调用受保护的方法之前针对集合中的每个元素求值。`filterTarget()`属性用于指定应过滤哪个参数（必须是非空集合实例）。如果方法只有一个集合参数，那么可以省略此属性。在表达式中，可以使用保留的名字“filterObject”表示当前正在评估的对象。
2. @RolesAllowed注解是一个JSR-250注解，用于==定义在访问方法或类时所需要的角色==。它允许==指定一个角色列表，只有具备这些角色的用户才能访问相应的方法或类==。在SpringSecurity中，`@RolesAllowed`注解可用于保护方法或类，限制只有具有特定角色的经过认证的用户才能访问。例如：如果有个方法只允许角色为“Admin”和“User”的用户访问，可以这样使用`@RolesAllowed`：在这种情况下，只有具有“Admin”或“User”角色的用户才能访问`secureMethod`方法。**但该注解是JAVA注解，本题问的是在SpringSecurity中的注解。**
```
@RolesAllowed({ "ADMIN", "USER" })
public void secureMethod() {
    // ...
}
```
3. @PreAuthorize是SpringSecurity中的一个注解，它用于在**方法调用之前**==实施访问控制==。通过==使用表达式==，`@PreAuthorize`可以根据表达式的计算结果决定是否允许对特定方法的访问。例如，您可以使用`@PreAuthorize`注解来检查用户是否具有特定权限或角色，如果满足条件则允许访问相应的方法。
4. @PostFilter是SpringSecurity提供的一个注解，用于在**方法调用之后**==对方法返回的数据进行过滤==。它允许==使用表达式==，根据表达式的计算结果来决定是否保留返回值中的某些元素。例如，可以使用`@PostFilter`注解来仅返回当前登录用户拥有的数据，从而实现在不同用户间数据隔离的安全策略。 

#### （SpringSecurity中负责管理用户授权信息）In Spring Security, **XXX** holds the information of an authority granted to an authenticated principal?
1. AuthorityGranted
2. PrincipalAuthority
3. AuthorityPrincipal
4. GrantedAuthority
##### 答案：4
###### 原因：
1. AuthorityGranted不存在
2. PrincipalAuthority不存在
3. AuthorityPrincipal不存在
4. GrantedAuthority是SpringSecurity中的一个接口，表示==授予用户的权限==。它代表了用户拥有的访问权限，用于在访问受保护资源时进行授权判断。`GrantedAuthority`接口具有一个方法`getAuthority()`，返回权限的`String`表示。

#### （哪个注解可以应用于controller层方法参数上）In Spring MVC, which of these annotations can be applied to the arguments of controller methods?Select all that apply.
1. @RequestParam
2. @RequestMapping
3. @RequestBody
4. @PathVariable
##### 答案：1、3、4
###### 原因：
1. @RequestParam注解用于将==HTTP请求参数绑定到方法参数==。它主要用于SpringMVC和SpringWebFlux的注解处理方法中。
2. @RequestMapping注解用于为==请求处理类和方法定义请求映射==。它主要用于SpringMVC和SpringWebFlux项目中。还可以根据`params`或`headers`属性，将映射限制到==具有特定参数或请求头==的请求。
3. @RequestBody注解用于==将HTTP请求体的内容绑定到处理方法的参数==。它主要用于处理带有请求体的HTTP请求（例如Post和Put请求），以便在处理方法中读取和使用请求数据。
4. @PathVariable注解用于将==URI模板变量绑定到方法参数==。它主要用于`@RequestMapping`注解的处理方法。通过使用`@PathVariable`，您可以==捕获请求URI中的动态变量部分==，并将其传递到控制器方法。 

#### （哪个是jdbcTemplate类的回调接口）Which of these is a callback interface for a JdbcTemplate class
1. ResultSetExtractor
2. PreparedStatementExtractor
3. StatementExtractor
4. All of the above
##### 答案：1
###### 原因：
1. ResultSetExtractor是一个接口，用于处理`java.sql.ResultSet`中的数据。它主要用于Spring的`JdbcTemplate`查询方法。实现此接口的类负责从`ResultSet`中提取数据，而无需处理异常。`SqlException`会由调用的`JdbcTemplate`自动捕获和处理。
2. PreparedStatementExtractor不存在
3. StatementExtactor不存在
拓展：jdbcTemplate类的回调接口有5个：`PreparedStatementCreator`、`PreparedStatementSetter`、`ResultSetExtractor`、`RowMapper`、`RowCallbackHandler`

#### （代表授权通过后用于身份验证的令牌）In Spring Security **XXX** object represents the token for authentication request after the request has been granted
1. UserDetails
2. Authentication
3. UserDetailsService
4. GrantedAuthority
##### 答案：2
###### 原因：
1. UserDetails 用于存放用户信息
2. Authentication 是一个核心概念，在SpringSecurity框架中用于==表示用户身份验证信息==。身份验证是一个过程，用于确定请求发起者的身份是否合法。SpringSecurity主要关注两个方面：身份验证（Authentication）和授权（Authorization）。`Authentication`对象通常包含以下信息：
主体（Principal）：表示已验证用户的身份，如用户名、电子邮件等。
凭证（Credentials）：通常是用户提供的密码，用于核实主体的身份。
权限（Authorities）：表示已验证用户拥有的权限，如角色、功能等。
当用户尝试访问受保护资源时，SpringSecurity首先确保用户已通过身份验证。一旦验证成功，框架将为该用户创建一个`Authentication`对象，并将其存储在安全上下文中。
3. UserDetailsService 用于通过用户名加载已存放的用户信息 
4. GrantedAuthority 用于存放用户授权信息

#### （Springboot配置文件中自定义自动配置）Which of these property is set in application.properties for customizing Spring boot auto-configuration?
1. spring.main.allow-bean-overriding=true
2. spring.main.allow-bean-definition-overriding=true
3. spring.main.bean-definition-overriding=true
4. spring.allow-bean-definition-overriding=true

##### 答案：2
###### 原因：
1. spring.main.allow-bean-overriding=true 不存在
2. spring.main.allow-bean-definition-overriding=true 是一个Spring Boot的配置选项，用于==控制是否允许用具有相同名称的新Bean定义覆盖现有Bean定义==。用于覆盖SpringBoot中自动配置类，已达到==自定义自动配置==的目的。
3. spring.main.bean-definition-overriding=true 不存在
4. spring.allow-bean-definition-overriding=true 不存在

#### （哪种注释用于仅测试SpringMVC组件）Which of these annotation is used in tests which aim to test only Spring MVC components?
1. @MvcTest
2. @WebTest
3. @WebMvcTest
4. @TestWebMvc

##### 答案：3
###### 原因：
1. @MvcTest不存在
2. @WebTest不存在
3. @WebMvcTest是一个SpringBoot测试注解，用于编写==针对SpringMvc应用程序的Web层测试==。主要关注于测试SpringMvc控制层，并加载与MVC组件（如控制器、拦截器等）相关的Bean。
4. @TestWebMvc不存在

#### （有助于实现SpringSecurity的功能点）Which of these help in implementing Spring Security in a Spring application?
1. Spring Security's Web Infrastructure using Filters
2. Both A and B
3. Spring AOP proxies

##### 答案：2
###### 原因：
Spring Security's Web Infrastructure using Filters（SpringSecurity的Web基础架构使用过滤器）SpringSecurity的==Web安全基础是建立在标准的Servlet过滤器上的==，意味着所有与HTTP请求相关的地方，都会看到一系列过滤器的执行。
Spring Security本身==不直接依赖于SpringAop代理==，它是一个独立的安全框架。但==某些高级功能==在内部实现时使用了AOP代理的方式，以增强功能或改善设计。例如：
**MethodSecurity** ：SpringSecurity提供基于方法的安全控制，可以在==方法级别设置访问规则==。
**RunAsManager** ： SpringSecurity提供RunAsManager，可以==动态切换当前用户==，这个功能也是使用AOP代理实现的。

#### （SpringBoot支持的日志框架）Which of these logging frameworks are supported by Spring boot? Select All that apply.
1. LogBack
2. Log4j2
3. Slf4j2
4. TinyLog

##### 答案：1、2
###### 原因：
SpringBoot支持的日志框架有：LogBack、Log4j、Log4j2、Slf4j、java.util.logging，==并不直接支持Slf4j2==，是因为Slf4j 2.x还不是非常成熟稳定，所以暂时还没有直接集成这个版本。而TinyLog是一个==极简的日志框架==，在==功能、性能、配置、社区支持==等方面都有不足。而SpringBoot追求提供==更丰富和更强大==的功能支持。所以没有对TinyLog进行直接支持。