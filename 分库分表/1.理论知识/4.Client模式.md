### TDDL

#### TDDL的简介

TDDL（Taobao Distributed Data Layer）框架，==主要解决了分库分表对应用的透明化已经异构数据库之间的数据复制，它是一个基于集中式配置的jdbc datasource实现，具有主备，读写分离，动态数据库配置等功能。==

TDDL是在持久层之下、JDBC驱动之上的中间件，它与JDBC规范保持一致，有效解决了分库分表的规则引擎问题，==实现了SQL解析、规则计算、表名替换、选择执行单元并合并结果集的功能==，同时解决了数据库的读写分离、高性能主备切换的问题，实现了数据库配置信息的统一管理。
![[Pasted image 20221216094633.png]]

==注： TDDL必须要依赖diamond配置中心（diamond是淘宝内部使用的一个管理持久配置的系统，目前淘宝内部绝大多数系统的配置，由diamond来进行统一管理，同时diamond也已开源）。==

==并且 TDDL的核心层Matrix尚未开源==

#### TDDL的三层结构
1. ==Matrix层分库分表、SQL解释、优化和执行等。==
2. Group层是经过读写分离和主备切换才会出现的最底层。
3. Atom层，它面对的是实实在在的每一个数据库，更多的工作在于对数据库的连接管理，比如当数据库的IP地址发生改变时，Atom层要动态感知，以免连接找不到地址。

![[Pasted image 20221216095406.png]]

#### TDDL 执行流程

![[Pasted image 20221216100545.png]]
TDDL的工作流程类似上图，==client发送一条SQL的执行语句，会优先传递给Matrix层。由Matrix解释SQL语句，优化，并根据查询条件路由到各个Group，转发SQL进行查询，各个Group根据权重选择其中一个Atom进行查询，各个Atom再将结果返回给Matrix，Matrix将结果合并返回给client。==具体的工作流程可以拆分成如下图。

![[Pasted image 20221216101135.png]]

##### #Matrix层 

Matrix层会先执行以下4个过程：
1. ==Sql的解析。==首先将Sql语句解析成一颗抽象语法树（Abstract Syntax Tree），解析成我们比较好处理的一个结构
2. 规则的匹配与计算。基于上一步创建的语法树查找匹配的规则，再根据规则去确定分库分表的结果。==这里有一个概念就是规则，规则这里可以简单的看做就是定义数据库怎么进行分库分表，要分成几张库几张表，库名和表名的命名是怎么样的。==规则的匹配就是根据SQL的语句确定，具体查询的子表是哪几张。
3. 表名替换。对于开发人员来说，它查询的表就是直接select * from A.B limit 10(A为数据库名，B为数据表名)。==但底层其实会把这些表名替换成==类似select * from A_000.B_001，select * from A_000.B.002，select * from A_001.TABLE_001这样的形式。==表名替换就是把总表的名称替换为这些子表的名字。==
4. Sql的转发。将上一步生成的各个Sql语句转发到对应的Group进行执行。这里如上图，我查询的条件时where id = 2 or 3。==那么转发给Group0的查询为where id=3，转发给group1的查询为where id = 2。查询的条件也会发生一定修改。==

这样4个步骤可以在Matrix层就实现了分库分表的功能，对原始的Sql进行分解，将原本单库单表的查询语句，底层转发到多库多表并行的进行执行，提高了数据库读写的性能。

##### #Group层

由Group层执行两个过程：
1. 根据==权重==选择AtomDs。通常会在主节点和副节点上读取数据，只在主节点上写入数据。
2. 具有==重试的策略==地在AtomDs上执行SQL。这个可以防止单个的AtomDs发生故障，那么会进入读重试，以确保尽可能多的数据访问可以在正常数据库中访问。

##### #Atom层

Atom层执行两个过程：
1. 读写数控制、线程并发数控制。同时会统计线程数、执行次数等信息。
2. ==执行sql，返回结果集。==Atom底层利用druid进行连接池的管理，具体查询还是对JDBC做了一定封装。执行完Sql后将结果返回给Matrix。

##### #Matrix层 

最后由Matrix执行合并
1. 结果集合并。Matrix将Atom层的返回的各个结果集进行合并Merge，返回给Client端。

### ShardingSphere-JDBC