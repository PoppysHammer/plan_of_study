### Nginx介绍
Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为”engine X“，是一个**高性能的HTTP**和**反向代理服务器**，同时也是一个**IMAP/POP3SMTP 代理服务器**。Nginx是由俄罗斯人lgor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，它已经在该站点运行超过两年半了。lgor Sysoev在建立该项目时，使用基于BSD许可。

### Nginx有什么优点
Nginx凭借其**稳定性**、**低资源消耗**、**简单配置**和**丰富的功能**，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。

1. 作为Web服务器，**Nginx处理静态文件、索引文件，自动索引的效率非常高**
2. 作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度
3. 作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还**支持简单的容错和利用算法进行负载均衡**
4. 在性能方面，Nginx是**专门为性能优化而开发的**，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对**5万个并发连接数的响应**，而且只占用很低的内存资源
5. 在稳定性方面，Nginx采取了**分阶段资源分配技术**，使得CPU与内存的占用率非常低。Nginx官方表示，**Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存**，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的。
6. 在高可用方面，**Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行**
Nginx具有很高的稳定性；支持热部署；代码质量非常高，代码很规范，手法成熟，模块扩展也很容易；采用了一些os提供的最新特性，如对sendfile(Linux2.2+),accept-filter(FreeBSD4.1+),TCP_DEFER_ACCEPT(Linux2.4+)的支持，从而大大提高了性能

### 什么是代理服务器、什么是正/反向代理
代理服务器一般是指**局域网内部的机器通过代理服务发送请求到互联网上的服务器**，代理服务器一般作用于客户端。比如GoAgent，FQ神器。

代理服务器是**介于客户端和Web服务器之间的另一台服务器**，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过**向代理服务器发送请求**，信号会先送到代理服务器，由**代理服务器来取回浏览器所需要的信息并传送给你的服务器**。![[Pasted image 20230330153832.png]]
一个完整的代理请求过程为：客户端首先与代理服务器创建连接，然后根据代理服务器所使用的代理协议，请求对目标服务器创建连接、获得目标服务器的指定资源。Web代理服务器是网络的中间实体。代理位于Web客户端和Web服务器之间，扮演”中间人“的角色。**HTTP的代理服务器既是Web服务器又是Web客户端。**

#### 那么什么是正/反向代理呢？
正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器提取到内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。
![[Pasted image 20230330154734.png]]
==正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明。==

**反向代理**服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。**Nginx**就是其中的一种反向代理服务器软件。![[Pasted image 20230330155905.png]]
==反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明。==

**注意！！**

正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。
反向代理正好与正向代理相反，对于**客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置**。客户端向反向代理的命名空间中的内容发送普通请求，接着**反向代理将判断向哪个原始服务器转交请求**，并将获得的内容返回给客户端。

### Nginx框架模型介绍

**进程组件角色：**

- Master进程： 监视工作进程的状态；当工作进程死掉后重启一个新的；处理信号和通知工作进程。
- Worker进程：处理客户端请求，从主进程处获得信号做相应的事情。
- CacheLoader进程：加载缓存索引文件信息，然后退出。
- CacheManager进程：管理磁盘的缓存大小，超过预定值大小后最少使用数据将被清除。

**Nginx的框架模型如下图：（一主多从）**
![[Pasted image 20230330162557.png]]
**框架模型流程如下图：**
![[Pasted image 20230330162615.png]]
==nginx采用多进程的模式，nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后（异常情况下），会自动重新启动新的worker进程。而基本的网络事件，则是放在woker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。==

### Nginx的请求处理流程
![[Pasted image 20230330165026.png]]

==最左边在WEB、EMAIL和TCP，也就是说大致有三种流量从这里进入Nginx以后，我们Nginx中有三个大的状态机，一个是处理TCP/UDP的4层的传输层状态机和处理应用层的HTTP状态以及处理邮件的MAIL状态机==

多种流量进入nginx后，nginx的三种状态机[非阻塞驱动模型epoll] ：**传输层状态机**、**http状态机**、**mail状态机** 在nginx解析出请求后，会动用线程池处理调用，将静态资源、反向代理、错误日志等信息分别导向不同的出口，如：fastcgi会导向php处理，html会导向nginx处理。并将处理的请求记录日志到本地或远程服务器

那么我们为什么叫它状态机呢？是因为Nginx核心的这个大绿色的框他是用非阻塞的事件驱动处理引擎就是用我们所熟知的epoll，那么一旦我们**使用这种异步处理引擎**之后，通常**都是需要用状态机把这个请求正确的识别和处理**。

基于这样的一种事件状态处理机，我们在解析出请求需要访问静态资源的时候，我们看到左下方这个箭头，那么它就找到了**静态资源**；对反向代理的内容，可以做**磁盘缓存**，缓存到磁盘上，也在下面左下方这条线；但是我们在处理静态资源的时候，**会有一个问题就是当整个内存已经不足以完全的缓存所有的文件和信息的时候，那么像sendFile这样的调用或者AIO会退化成阻塞的磁盘调用，所以在这里我们需要有一个线程池来处理**，对于每一个处理完成的请求会进入access日志或error日志。

那么这里也是进入了磁盘中的，当然我们可以通过syslog协议把它进入到远程的机器上，那么更多的时候我们的Nginx是作为负载均衡或者反向代理来使用的，就是我们可以把请求通过协议级（HTTP，Mail及stream（TCP））传输到后面的服务器，也可以通过例如应用层的一些协议（FastCGI、uWSGI、SCGI、memcached）代理到相应的应用服务器。以上就是Nginx的请求处理流程。

### Nginx接受请求链接事件模块流程

#### 操作系统内核
三次握手，当用户发来一个SYN报文时，系统内核会返回一个SYN+ACK确认给客户端，当用户再次发送ACK来的时候，此时就已经建立了三次握手，三次握手后，操作系统会根据系统内的负载均衡算法来选中一个worker线程，它会返回一个建立连接的epoll_wait的句柄。拿到了epoll_wait的链接句柄后找到它监听的端口80或443等端口。拿到端口后，开始调用accept方法来分配512字节的连接内存池（connection_pool_size:512）。分配完内存池后，http模块会从事件中接入请求的处理过程。

http模块启动后，ngx_http_init_connection设置并启用一个回调方法：epoll_ctl，并为这个方法添加定时器（client_header_timeout:60s）然后将读事件添加到这个epoll事件中，并开始计时60s，如果60秒没收到请求就会返回超时。

在请求完成后，nginx会将请求数据读取到用户态中，并在连接内存池中为他分配一个读的缓冲区：client_header_buffer_size:1k[之前分配的是512字节，这里是可扩展的分配的1k，这里的1k是强制占用，无论你现有字节会不会超过1k都会强行占用1k]

#### 接收请求HTTP模块
**收到请求的URI后，开始分配内存池，并做上下文分析**，分析每个head和ttp协议，所以这里需要分配一个默认请求内存池：request_poll_size:4k；此时状态机会解析请求行，如：方法名、url、协议，解析请求行的过程中可能会发现有的URL更大，已经超过了我们之前设置的1k了。此时我们会调用一个大内存：large_client_header_buffer:4.8k（最多32k）;当状态机解析完了请求行后，标识URI用于指向请求行（这里也是nginx强大的原因，他可以指定请求行，不用遍历）标识结束后，开始接受head，并开始解析header。同时复用large_client_header_buffers:4.8k的内存，接受完整的header后标识header，并且移除超时定时器（client_header_timeout:60s）移除定时器后就开始了11个阶段的http请求处理过程。
![[Pasted image 20230331100542.png]]

##### 11个阶段的http请求处理过程
![[Pasted image 20230403094109.png]]