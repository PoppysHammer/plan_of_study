#### 前言
好的代码不止为了完成现有功能，也会考虑后续扩展。在结构设计上松耦合易读易扩展，在领域实现上高内聚不对外暴露实现细节不被外不干扰。

**谁发明了设计模式？** 设计模式的概念最早是由`克里斯托佛·亚历山大`在其著作`《建筑模式语言》`中首次提出的。本书介绍了城市设计的”语言“，提供了253个描述城镇、邻里、住宅、花园、房间及西部构造的模式，而此类”语言“的基本单元就是模式。后来，`埃里希·伽马`、`约翰·弗利赛德斯`、`拉尔夫·约翰逊`和`理查德·赫尔姆`这四位作者接受了模式的概念。1994年，他们出版了`《设计模式：可复用面向对象软件的基础》`一书，将设计模式的概念应用到程序开发领域中。

#### 工厂方法模式介绍
![[Pasted image 20230222145328.png]]
工厂模式又称工厂方法模式，是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

这种设计模式也是Java开发中**最常见**的一种设计模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的直到调用即可，同时，这也是去掉众多`ifelse`的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样降低开发成本。==但这些问题都可以在后续的设计模式结合使用中，逐步降低。==

#### 模拟发奖多种商品
![[Pasted image 20230222150103.png]]
为了可以让整个学习的案例更加贴合实际开发，这里模拟互联网中在营销场景下的业务。由于营销场景的复杂、多变、临时的特性，它所需要的设计需要更加深入，否则会经常面临各种紧急CRUD操作，从而让代码结构混乱不堪，难以维护。

在营销场景中经常会有某个用户做了一些操作；打卡、分享、留言、邀请注册等等，进行返利积分，最后通过积分再兑换商品，从而促活和拉新。

那么在这里我们模拟积分兑换中的发放多种类型商品，加入现在我们有如下三种类型的商品接口；
| 序号 | 类型 | 接口 |
| - | - |  - |
| 1 | 优惠券 | CouponResult sendCoupon(String uId,String couponNumber,String uuid) |
| 2 | 实物商品 |  Boolean deliverGoods(DeliverReq req) |
| 3 | 第三方爱奇艺兑换卡 |  void grantToken(String bindMobileNumber, String cardId) | 

**从以上接口来看有如下信息**
- 三个接口返回类型不同，有对象类型、布尔类型、还有一个空类型。
- 入参不同，发放优惠券需要防重、兑换卡需要卡ID、实物商品需要发货位置（对象中含有）
- 另外可能会随着后续的业务的发展，会新增其他种商品类型。因为你所有的开发需求都是随着业务对市场的拓展而带来的。

#### 实现
##### ifElse实现
1. 工程结构
`````
itstack-demo-design-1-01
└── src
    ├── main
    │   └── java
    │       └── org.itstack.demo.design
    │           ├── AwardReq.java
    │           ├── AwardRes.java
    │           └── PrizeController.java 
    └── test
         └── java
             └── org.itstack.demo.design.test
                 └── ApiTest.java
`````
- 结构上非常简单，所有业务逻辑都在controller处理，通过`ifelse`判断请求类型做不同奖励的发放处理。
- 这样的代码会非常直接的实现出来业务需求的一坨代码，如果仅从业务角度看，研发如期甚至提前实现了功能。
- 这样的代码在目前看来并不会有什么问题，但如果再经过几次迭代和拓展，接手这段代码的研发将十分痛苦。重构成本高==需要清理之前每一个接口的使用，测试回归验证时间长，需要全部验证一次==。这也就是很多人并不愿意接手别人的代码，如果接手了又被压榨开发时间。那么可想而知这样的`ifelse`还会继续增加

##### 工厂模式开发
1. 工程结构
`````
itstack-demo-design-1-02
└── src
    ├── main
    │   └── java
    │       └── org.itstack.demo.design
    │           ├── store    
    │           │   ├── impl
    │           │   │   ├── CardCommodityService.java
    │           │   │   ├── CouponCommodityService.java 
    │           │   │   └── GoodsCommodityService.java  
    │           │   └── ICommodity.java
    │           └── StoreFactory.java 
    └── test
         └── java
             └── org.itstack.demo.design.test
                 └── ApiTest.java
`````
- 上面的工程结构看上去清晰了、这样分层也可以更好扩展了，**我们可以将每一种奖品的实现都包括在自己的类中，新增、修改或者删除都不会影响其他奖品功能的测试，降低回归测试的可能。**
- 后续再新增的奖品只需要按照此结构进行填充即可，非常易于维护和扩展。
- 在统一了入参以及出参后，调用方不需要再关心奖品发放的内部逻辑，按照统一的逻辑即可处理。
- 在商店的工厂类里，按照类型实现各种商品的服务，可以非常整洁的处理代码，后续新增的商品在这里扩展入口即可。

#### 总结
- 工厂方法模式并不复杂，甚至这样的开发结构在有所理解后，会发现更加简单了。
- 这样开发的优点是：`避免创建者与具体的产品逻辑耦合`、`满足单一职责，每一个业务逻辑实现都在所属自己的类中完成`
、`满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型`。但同样也会带来一些问题，比如有非常多的奖品类型，那么实现的子类就会急速扩展。因此也需要使用其他的模式进行优化，在后续的设计模式中会逐步涉及到。